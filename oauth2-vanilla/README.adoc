[[_sso_with_oauth2_angular_js_and_spring_security_part_v]]
= Single Sign On with OAuth2

In this section we continue <<_the_api_gateway_pattern_angular_js_and_spring_security_part_iv,our discussion>> of how to use http://projects.spring.io/spring-security[Spring Security] with http://angular.io[Angular] in a "single page application". Here we show how to use http://projects.spring.io/spring-security-oauth/[Spring Security OAuth] to do Single Sign On and OAuth2 token authentication to backend resources. This is the fifth in a series of sections, and you can catch up on the basic building blocks of the application or build it from scratch by reading the <<_spring_and_angular_js_a_secure_single_page_application,first section>>, or you can just go straight to the https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/oauth2[source code in Github]. In the <<_the_api_gateway_pattern_angular_js_and_spring_security_part_iv,last section>> we built a small distributed application that used https://github.com/spring-projects/spring-session/[Spring Session] to authenticate the backend resources and http://projects.spring.io/spring-cloud/[Spring Cloud] to implement an embedded API Gateway in the UI server. In this section we extract the authentication responsibilities to a separate server to make our UI server the first of potentially many Single Sign On applications to the authorization server. This is a common pattern in many applications these days, both in the enterprise and in social startups. We will use an OAuth2 server as the authenticator, so that we can also use it to grant tokens for the backend resource server.

____
Reminder: if you are working through this section with the sample application, be sure to clear your browser cache of cookies and HTTP Basic credentials. In Chrome the best way to do that for a single server is to open a new incognito window.
____

== Creating an OAuth2 Authorization Server

Our first step is to create a new server to handle authentication and token management. Following the steps in <<_spring_and_angular_js_a_secure_single_page_application,Part I>> we can begin with https://start.spring.io[Spring Boot Initializr]. E.g. using curl on a UN*X like system:

[source]
----
$ curl https://start.spring.io/starter.tgz -d dependencies=web \
-d dependencies=security -d name=authserver | tar -xzvf -
----

You can then import that project (it's a normal Maven Java project by default) into your favourite IDE, or just work with the files and "mvn" on the command line.

=== Adding the OAuth2 Dependencies

We need to add the https://github.com/spring-projects-experimental/spring-authorization-server[Spring Authorization Server] dependency, so in our https://github.com/spring-guides/tut-spring-security-and-angular-js/blob/master/oauth2/authserver/pom.xml[POM] we add:

.pom.xml
[source,xml]
----
<dependency>
    <groupId>org.springframework.security.experimental</groupId>
    <artifactId>spring-security-oauth2-authorization-server</artifactId>
    <version>0.0.2</version>
</dependency>
----

NOTE: The https://github.com/spring-projects-experimental/spring-authorization-server[Spring Authorization Server] is experimental and may change in the future.

First, we import the `OAuth2AuthorizationServerConfiguration`, which includes the OAuth 2.0 Authorization Server support.

.AuthorizationServerConfiguration.java
[source,java]
----
@EnableWebSecurity
@Import(OAuth2AuthorizationServerConfiguration.class)
public class AuthorizationServerConfiguration {
}
----

Next, we register a `KeyManager` that provides the public/private/symmetric keys

.AuthorizationServerConfiguration.java
[source,java]
----
@EnableWebSecurity
@Import(OAuth2AuthorizationServerConfiguration.class)
public class AuthorizationServerConfiguration {
    @Bean
    public KeyManager keyManager() {
        return new StaticKeyGeneratingKeyManager();
    }
}
----

Then, we register a client "acme" with the "authorization_code" grant type.

.AuthorizationServerConfiguration.java
[source,java]
----
...
@EnableWebSecurity
@Import(OAuth2AuthorizationServerConfiguration.class)
public class AuthorizationServerConfiguration {

    ...

    @Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient pilotClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("acme")
                .clientAuthenticationMethod(ClientAuthenticationMethod.BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .redirectUri("http://localhost:8080/login/oauth2/code/spring")
                .build();
        return new InMemoryRegisteredClientRepository(pilotClient);
    }

}
----

Now let's get it running on port 9999, with a predictable password for testing:

.application.properties
[source,properties]
----
server.port=9999
spring.security.user.password=password
server.contextPath=/uaa
...
----

We also set the context path so that it doesn't use the default ("/") because otherwise you can get cookies for other servers on localhost being sent to the wrong server. So get the server running and we can make sure it is working:

[source]
----
$ mvn spring-boot:run
----

or start the `main()` method in your IDE.

=== Testing the Authorization Server

Our server is using the Spring Boot default security settings, so like the server in <<_spring_and_angular_js_a_secure_single_page_application,Part I>> it will be protected by HTTP Basic authentication.To initiate an https://tools.ietf.org/html/rfc6749#section-1.3.1[authorization code token grant] you visit the authorization endpoint, e.g. at http://localhost:9999/uaa/oauth2/authorize?response_type=code&client_id=acme&redirect_uri=http://localhost:8080/login/oauth2/code/spring[http://localhost:9999/uaa/oauth2/authorize?response_type=code&client_id=acme&redirect_uri=http://localhost:8080/login/oauth2/code/spring] once you have authenticated you will get a redirect to localhost:8080 with an authorization code attached, e.g. http://localhost:8080/login/oauth2/code/spring?code=jYWioI[http://localhost:8080/login/oauth2/code/spring?code=jYWioI].

The code can be exchanged for an access token using the "acme" client credentials on the token endpoint:

[source]
----
$ curl acme:acmesecret@localhost:9999/uaa/oauth2/token  \
-d grant_type=authorization_code -d client_id=acme     \
-d redirect_uri=http://localhost:8080/login/oauth2/code/spring -d code=jYWioI
{"access_token":"eyJraWQiOiI0YjQ2NmVjNi1lNTU4LTRhNzUtOTA3OS01Yjg5YjQzNmJlYjciLCJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9eyJraWQiOiI0YjQ2NmVjNi1lNTU4LTRhNzUtOTA3OS01Yjg5YjQzNmJlYjciLCJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJ1c2VyIiwiYXVkIjoiYWNtZSIsIm5iZiI6MTYwMjg1NjQ3Nywic2NvcGUiOltdLCJpc3MiOiJodHRwczpcL1wvb2F1dGgyLnByb3ZpZGVyLmNvbSIsImV4cCI6MTYwMjg2MDA3NywiaWF0IjoxNjAyODU2NDc3LCJqdGkiOiI3ZWRlZjZlOS00MWI2LTQzMDEtOTlkZi03MjU3ODIzNGY0NmMifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c","token_type":"Bearer","expires_in":"3599"}
----

The access token is a JWT ("eyJraWQiOiI0YjQ2..."), backed by an in-memory token store in the server.

If you followed the link above you would have seen the whitelabel UI provided by Spring Security. To start with we will use this and we can come back later to beef it up like we did in <<_the_login_page_angular_js_and_spring_security_part_ii,Part II>> for the self-contained server.

[[changing-the-resource-server]]
== Changing the Resource Server

If we follow on from <<_the_api_gateway_pattern_angular_js_and_spring_security_part_iv,Part IV>>, our resource server is using https://github.com/spring-projects/spring-session/[Spring Session] for authentication, so we can take that out and replace it with Spring Security OAuth2 Resource Server.. We also need to remove the Spring Session and Redis dependencies, so replace this:

.pom.xml
[source,xml]
----
<dependency>
  <groupId>org.springframework.session</groupId>
  <artifactId>spring-session</artifactId>
</dependency>
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-redis</artifactId>
</dependency>
----

with this:

.pom.xml
[source,xml]
----
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
</dependency>
----

and then remove the session `Filter` from the https://github.com/spring-guides/tut-spring-security-and-angular-js/blob/master/vanilla-oauth2/resource/src/main/java/demo/ResourceApplication.java[main application class].

.ResourceApplication.java
[source,java]
----
@SpringBootApplication
@RestController
class ResourceApplication {

  @RequestMapping("/")
  public Message home() {
    return new Message("Hello World");
  }

  public static void main(String[] args) {
    SpringApplication.run(ResourceApplication.class, args);
  }
}

----

With that one change the app is ready to challenge for an access token instead of HTTP Basic, but we need a config change to actually finish the process. We are going to add a small amount of external configuration (in "application.properties") to allow the resource server to decode the tokens it is given and authenticate a user:

.application.properties
[source,properties]
----
...
spring.security.oauth2.resourceserver.jwt.jwk-set-uri=http://localhost:9999/uaa/oauth2/jwks
----

This tells the server that it can use the "/user" endpoint to retrieve the https://tools.ietf.org/html/rfc7517[JSON Web Key (JWK)] Set from the Authorization Server, which contains the cryptographic key(s) used to verify the https://tools.ietf.org/html/rfc7515[JSON Web Signature (JWS)] of the token.

Run the application and hit the home page with a command line client:

[source]
----
$ curl -v localhost:9000
> GET / HTTP/1.1
> Host: localhost:9000
> User-Agent: curl/7.64.1
> Accept: */*
>
< HTTP/1.1 401
...
< WWW-Authenticate: Bearer
----

and you will see a 401 with a "WWW-Authenticate" header indicating that it wants a bearer token.

NOTE: the `jwk-set-uri` is by far not the only way of hooking a resource server up with a way to decode tokens. Different options (naturally) provide different benefits and trade-offs, but a full discussion of those is outside the scope of this section.

== Implementing the User Endpoint

On the authorization server we can easily add that endpoint

.AuthserverApplication.java
[source,java]
----
@SpringBootApplication
@RestController
public class AuthserverApplication {

  @RequestMapping("/user")
  public Principal user(Principal user) {
    return user;
  }

  ...

}
----

We added a `@RequestMapping` the same as the UI server in <<_the_login_page_angular_js_and_spring_security_part_ii,Part II>>.

The "/user" endpoint should require Bearer token authentication. To achieve this, we need to make our Authorization Server also be a Resource Server.

.AuthorizationServerConfiguration.java
[source,java]
----
@EnableWebSecurity
@Import(OAuth2AuthorizationServerConfiguration.class)
public class AuthorizationServerConfiguration {

    @Configuration
    @Order(1)
    public static class UserSecurityConfiguration extends WebSecurityConfigurerAdapter {
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http
                    .antMatcher("/user")
                    .authorizeRequests(authorize -> authorize
                            .anyRequest().authenticated()
                    )
                    .oauth2ResourceServer(auth -> auth
                            .jwt(jwt -> jwt
                                    .jwkSetUri("http://localhost:9999/uaa/oauth2/jwks")
                            )
                    );
        }
    }

    @Configuration
    public static class AuthServerSecurityConfiguration extends WebSecurityConfigurerAdapter {
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http
                    .authorizeRequests(authorize -> authorize
                            .anyRequest().authenticated()
                    )
                    .formLogin(withDefaults())
                    .httpBasic(withDefaults());
        }
    }
    ...
}
----

Now we have 2 security configurations, one specific to the "/user" endpoint and the other for the rest of the endpoints.

With that endpoint in place we can test it and the greeting resource, since they both now accept bearer tokens that were created by the authorization server:

[source]
----
$ TOKEN=2219199c-966e-4466-8b7e-12bb9038c9bb
$ curl -H "Authorization: Bearer $TOKEN" localhost:9000
{"id":"03af8be3-2fc3-4d75-acf7-c484d9cf32b1","content":"Hello World"}
$ curl -H "Authorization: Bearer $TOKEN" localhost:9999/uaa/user
{"details":...,"principal":{"subject":"user",...},"name":"user"}
----

(substitute the value of the access token that you obtain from your own authorization server to get that working yourself).

== The UI Server

The final piece of this application we need to complete is the UI server, extracting the authentication part and delegating to the authorization server. So, as with link:#changing-the-resource-server[the resource server], we first need to remove the Spring Session and Redis dependencies and replace them with Spring Security OAuth2 Client.

.pom.xml
[source,xml]
----
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-client</artifactId>
</dependency>
----

Once that is done we can remove the session filter and the "/user" endpoint as well:

.UiApplication.java
[source,java]
----
@SpringBootApplication
public class UiApplication {

  public static void main(String[] args) {
    SpringApplication.run(UiApplication.class, args);
  }

...

}
----

Next, we need to add a `WebSecurityConfigurerAdapter`, enabling OAuth2 Login:

.UISecurityConfiguration.java
[source,java,indent=0]
----
@EnableWebSecurity
public class UiSecurityConfiguration extends WebSecurityConfigurerAdapter {
    @Override
    public void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests(authorize -> authorize
                .antMatchers("/index.html", "/").permitAll()
                .anyRequest().authenticated()
            )
            .logout(logout -> logout
                .logoutSuccessUrl("/")
            )
            .oauth2Login(withDefaults());
    }

    @Bean
    WebClient webClient(ClientRegistrationRepository clientRegistrationRepository,
        OAuth2AuthorizedClientRepository authorizedClientRepository) {
        ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2 =
            new ServletOAuth2AuthorizedClientExchangeFilterFunction(clientRegistrationRepository,
                authorizedClientRepository);
        oauth2.setDefaultOAuth2AuthorizedClient(true);
        return WebClient.builder().apply(oauth2.oauth2Configuration()).build();
    }

    @Override
    public void configure(WebSecurity web) {
        web.ignoring().antMatchers("/*.bundle.*");
    }
}
----

The main changes are that the matchers go into their own method,
and there is no need for `formLogin()` any more.
The explicit `logout()` configuration explicitly adds a success url that
is unprotected, so that an XHR request to `/logout` will return successfully.

We also configured a `WebClient` with OAuth2 Client support.

For this, we need to add the the WebFlux dependency to our pom.xml.

.pom.xml
[source,xml]
----
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>
----

NOTE: It is recommended to be cautious with this feature since all HTTP requests will receive the access token.

There are also some mandatory external configuration properties
to be able to contact and authenticate with the right authorization server.
So we need this in `application.yml`:

.application.yml
[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        registration:
          acme:
            provider: spring
            client-id: acme
            client-secret: acmesecret
            authorization-grant-type: authorization_code
            redirect-uri: "{baseUrl}/login/oauth2/code/spring"
        provider:
          spring:
            authorization-uri: http://localhost:9999/uaa/oauth2/authorize
            token-uri: http://localhost:9999/uaa/oauth2/token
            user-info-uri: http://localhost:9999/uaa/user
            user-name-attribute: name
----

The bulk of that is about the OAuth2 client ("acme") and the
authorization server locations. There is also a `user-info-uri`
so that the user can be authenticated in the UI app itself.

Now that we have OAuth2 Login enabled, we can retrieve information about the logged in user and return it in the "/user" endpoint. We also add a "/resource" endpoint, where we call the resource server using the `WebClient` we just created.

.UserController.java
[source,java,indent=0]
----
@RestController
public class UserController {

    private final WebClient webClient;

    public UserController(WebClient webClient) {
        this.webClient = webClient;
    }

    @RequestMapping("/user")
    public Authentication user(Authentication user) {
        return user;
    }

    @RequestMapping("/resource")
    public Object resource() {
        return this.webClient.get()
            .uri("http://localhost:9000")
            .retrieve()
            .bodyToMono(Object.class)
            .block();
    }
}
----

=== In the Client

There are some tweaks to the UI application on the front end that we still need to make to trigger the redirect to the authorization server. In this simple demo we can strip the Angular app down to its bare essentials so you can see what is going on more clearly. So we forgo, for now, the use of forms or routes, and we go back to a single Angular component:

.app.component.ts
[source,javascript]
----
include::ui/src/app/app.component.ts[indent=0]
----

The `AppComponent` handles everything, fetching the user details and, if successful, the greeting. It also provides the `logout` function.

Now we need to create the template for this new component:

app.component.html
[source,html]
----
include::ui/src/app/app.component.html[indent=0]
----

and include it in the home page as `<app-root/>`.

Note that the navigation link for "Login" is a regular link with an `href` (not an Angular route). The "/oauth2/authorization/acme" endpoint that this goes to is handled by Spring Security and if the user is not authenticated it will result in a redirect to the authorization server.

== How Does it Work?

Run all the servers together now, and visit the UI in a browser at http://localhost:8080[http://localhost:8080]. Click on the "login" link and you will be redirected to the authorization server to authenticate, before being redirected to the home page in the UI with the greeting fetched from the OAuth2 resource server using the same token as we authenticated the UI with.

The interactions between the browser and the backend can be seen in your browser if you use some developer tools (usually F12 opens this up, works in Chrome by default, may require a plugin in Firefox). Here's a summary:

|===
|Verb |Path |Status |Response

|GET |/ |200 |index.html
|GET |/*.js |200 |Assets from angular
|GET |/user |302 |Redirect to login page
|GET |/oauth2/authorization/acme |302 |Redirect to auth server
|GET |(uaa)/oauth2/authorize |401 |(ignored)
|GET |/login |302 |(ignored)
|GET |/oauth2/authorization/acme |302 |Redirect to auth server
|GET |(uaa)/oauth2/authorize |302 |Redirect to login page
|GET |(uaa)/login |200 |Authorization Server login page
|POST |(uaa)/login |302 |User is authenticated
|GET |(uaa)/oauth2/authorize |302 |User approves grant, redirect to /login
|GET |/login/oauth2/code/spring |302 |Redirect to home page
|GET |/user |200 |(Proxied) JSON authenticated user
|GET |/app.html |200 |HTML partial for home page
|GET |/resource |200 |JSON greeting from resource server
|===

The requests prefixed with (uaa) are to the authorization server. The responses that are marked "ignored" are responses received by Angular in an XHR call, and since we aren't processing that data they are dropped on the floor. We do look for an authenticated user in the case of the "/user" resource, but since it isn't there in the first call, that response is dropped.

== The Logout Experience

If you click on the "logout" link you will see that the home page changes (the greeting is no longer displayed) so the user is no longer authenticated with the UI server. Click back on "login" though and you actually _don't_ need to go back through the authentication and approval cycle in the authorization server (because you haven't logged out of that). Opinions will be divided as to whether that is a desirable user experience, and it's a notoriously tricky problem (Single Sign Out: http://www.sciencedirect.com/science/article/pii/S2214212614000179[Science Direct article] and https://wiki.shibboleth.net/confluence/display/SHIB2/SLOIssues[Shibboleth docs]). The ideal user experience might not be technically feasible, and you also have to be suspicious sometimes that users really want what they say they want. "I want 'logout' to log me out" sounds simple enough, but the obvious response is, "Logged out of what? Do you want to be logged out of _all_ the systems controlled by this SSO server, or just the one that you clicked the 'logout' link in?" If you are interested then there is <<_oauth2_logout_angular_js_and_spring_security_part_ix,a later section>> of this tutorial where it is discussed in more depth.

== Conclusion

This is almost the end of our shallow tour through the Spring Security and Angular stack. We have a nice architecture now with clear responsibilities in three separate components, UI, resource server and authorization server/token granter. The amount of non-business code in all layers is now minimal, and it's easy to see where to extend and improve the implementation with more business logic. The next steps will be to tidy up the UI in our authorization server, and probably add some more tests, including tests on the JavaScript client. Another interesting task is to extract all the boiler plate code and put it in a library (e.g. "spring-security-angular") containing Spring Security and Spring Session autoconfiguration and some webjars resources for the navigation controller in the Angular piece. Having read the sections in this series, anyone who was hoping to learn the inner workings of either Angular or Spring Security will probably be disappointed, but if you wanted to see how they can work well together and how a little bit of configuration can go a long way, then hopefully you will have had a good experience.

The <<_multiple_ui_applications_and_a_gateway_single_page_application_with_spring_and_angular_js_part_vi,next section>> in the series is about access decisions (beyond authentication) and employs multiple UI applications behind the same proxy.
